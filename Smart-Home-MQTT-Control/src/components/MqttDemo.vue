<template>
  <div class="mqtt-demo">
    <!-- È°∂ÈÉ®Áä∂ÊÄÅÊ†è -->
    <div class="status-bar" :class="{ connected: isConnected }">
      <div class="status-indicator">
        <span class="status-dot" :class="{ active: isConnected }"></span>
        <span class="status-text">{{ isConnected ? "Â∑≤ËøûÊé•" : "Êú™ËøûÊé•" }}</span>
      </div>
      <div class="connection-info" v-if="isConnected">
        <el-icon>
          <Connection />
        </el-icon>
        <span class="connection-text">{{ connection.host }}:{{ connection.port }}</span>
      </div>
    </div>

    <!-- ËøûÊé•ÈÖçÁΩÆÂç°ÁâáÔºàÂèØÊäòÂè†Ôºâ -->
    <el-card class="config-card" shadow="never">
      <template #header>
        <div class="card-header clickable" @click="configCollapsed = !configCollapsed">
          <div class="header-left">
            <el-icon class="header-icon">
              <Setting />
            </el-icon>
            <span class="card-title">ËøûÊé•ÈÖçÁΩÆ</span>
          </div>
          <el-icon class="collapse-icon" :class="{ collapsed: configCollapsed }">
            <ArrowDown />
          </el-icon>
        </div>
      </template>
      <el-collapse-transition>
        <div v-show="!configCollapsed">
          <el-form label-position="top" :model="connection">
            <el-row :gutter="16">
              <el-col :xs="24" :sm="12" :md="8">
                <el-form-item label="ÂçèËÆÆ">
                  <el-select v-model="connection.protocol" :disabled="isConnected">
                    <el-option label="ws://" value="ws"></el-option>
                    <el-option label="wss://" value="wss"></el-option>
                  </el-select>
                </el-form-item>
              </el-col>
              <el-col :xs="24" :sm="12" :md="8">
                <el-form-item label="‰∏ªÊú∫Âú∞ÂùÄ">
                  <el-input v-model="connection.host" :disabled="isConnected"></el-input>
                </el-form-item>
              </el-col>
              <el-col :xs="24" :sm="12" :md="8">
                <el-form-item label="Á´ØÂè£">
                  <el-input v-model.number="connection.port" type="number" :disabled="isConnected"></el-input>
                </el-form-item>
              </el-col>
              <el-col :xs="24" :sm="12" :md="8">
                <el-form-item label="ÂÆ¢Êà∑Á´Ø ID">
                  <el-input v-model="connection.clientId" :disabled="isConnected"></el-input>
                </el-form-item>
              </el-col>
              <el-col :xs="24" :sm="12" :md="8">
                <el-form-item label="Áî®Êà∑Âêç">
                  <el-input v-model="connection.username" :disabled="isConnected"></el-input>
                </el-form-item>
              </el-col>
              <el-col :xs="24" :sm="12" :md="8">
                <el-form-item label="ÂØÜÁ†Å">
                  <el-input v-model="connection.password" type="password" show-password
                    :disabled="isConnected"></el-input>
                </el-form-item>
              </el-col>
              <el-col :span="24">
                <div class="button-group">
                  <el-button type="primary" size="large" :disabled="isConnected" @click="createConnection"
                    :loading="btnLoadingType === 'connect'" color="#1976d2">
                    <el-icon>
                      <Connection />
                    </el-icon>
                    <span>{{ isConnected ? "Â∑≤ËøûÊé•" : "ËøûÊé•" }}</span>
                  </el-button>
                  <el-button v-if="isConnected" size="large" @click="destroyConnection"
                    :loading="btnLoadingType === 'disconnect'" color="#424242">
                    <el-icon>
                      <Close />
                    </el-icon>
                    <span>Êñ≠ÂºÄ</span>
                  </el-button>
                </div>
              </el-col>
            </el-row>
          </el-form>
        </div>
      </el-collapse-transition>
    </el-card>

    <!-- ÁÅØÂÖâÊéßÂà∂Âç°Áâá -->
    <el-card class="light-control-card" shadow="never">
      <template #header>
        <div class="card-header">
          <div class="header-left">
            <el-icon class="header-icon">
              <Sunny />
            </el-icon>
            <span class="card-title">ÁÅØÂÖâÊéßÂà∂</span>
          </div>
          <div class="header-actions">
            <el-button size="small" @click="toggleAllLights(true)" :disabled="!isConnected" text>
              ÂÖ®ÂºÄ
            </el-button>
            <el-button size="small" @click="toggleAllLights(false)" :disabled="!isConnected" text>
              ÂÖ®ÂÖ≥
            </el-button>
            <el-button size="small" @click="queryLightStatus" :disabled="!isConnected" text>
              Âà∑Êñ∞
            </el-button>
          </div>
        </div>
      </template>
      <div class="lights-grid">
        <div v-for="light in lights" :key="light.id" class="light-card"
          :class="{ active: light.state, disabled: !isConnected }" @click="toggleLight(light)">
          <div class="light-icon">{{ light.icon }}</div>
          <div class="light-info">
            <div class="light-name">{{ light.name }}</div>
            <div class="light-status">{{ light.state ? "ÂºÄÂêØ" : "ÂÖ≥Èó≠" }}</div>
          </div>
          <el-switch v-model="light.state" size="large" :disabled="!isConnected" @click.stop
            @change="handleSingleLightControl(light)" />
        </div>
      </div>
    </el-card>

    <!-- Ë≠¶Êä•ÊéßÂà∂Âç°Áâá -->
    <el-card class="alarm-card" shadow="never">
      <template #header>
        <div class="card-header">
          <div class="header-left">
            <el-icon class="header-icon">
              <Bell />
            </el-icon>
            <span class="card-title">Ë≠¶Êä•ÊéßÂà∂</span>
          </div>
          <div class="header-actions">
            <el-button size="small" @click="queryAlarmStatus" :disabled="!isConnected" text>
              Âà∑Êñ∞
            </el-button>
          </div>
        </div>
      </template>
      <div class="alarm-control" :class="{ active: alarmControl.state, disabled: !isConnected }" @click="toggleAlarm">
        <div class="alarm-icon" :class="{ active: alarmControl.state }">üîî</div>
        <div class="alarm-info">
          <div class="alarm-title">Ë≠¶Êä•Á≥ªÁªü</div>
          <div class="alarm-status">{{ alarmControl.state ? "ÂºÄÂêØ" : "ÂÖ≥Èó≠" }}</div>
        </div>
        <el-switch v-model="alarmControl.state" size="large" :disabled="!isConnected" @click.stop
          @change="handleAlarmControl" />
      </div>
    </el-card>

    <!-- Êñá‰ª∂ÁÆ°ÁêÜÂç°Áâá -->
    <el-card class="file-management-card" shadow="never">
      <template #header>
        <div class="card-header">
          <div class="header-left">
            <el-icon class="header-icon">
              <Folder />
            </el-icon>
            <span class="card-title">Êñá‰ª∂ÁÆ°ÁêÜ</span>
          </div>
          <el-button size="small" :disabled="!isConnected || fileOpLoading" @click="refreshFileList"
            :loading="fileOpLoading" text>
            <el-icon>
              <Refresh />
            </el-icon>
            <span class="btn-text">Âà∑Êñ∞</span>
          </el-button>
        </div>
      </template>

      <!-- Êñá‰ª∂‰∏ä‰º†Âå∫Âüü -->
      <div class="file-upload-section">
        <div class="drop-zone" :class="{ 'drag-over': isDragOver, 'has-file': selectedFile, 'disabled': !isConnected }"
          @dragover.prevent="isConnected && (isDragOver = true)" @dragleave.prevent="isDragOver = false"
          @drop.prevent="isConnected && handleFileDrop($event)" @click="isConnected && triggerFileSelect()">
          <div v-if="selectedFile" class="file-preview">
            <div class="file-preview-content">
              <el-icon class="file-icon">
                <Document />
              </el-icon>
              <div class="file-info">
                <div class="file-name">{{ selectedFile.name }}</div>
                <div class="file-size">{{ formatFileSize(selectedFile.size) }}</div>
              </div>
            </div>
            <div class="file-actions">
              <el-button type="primary" size="large" :disabled="!isConnected || fileOpLoading" @click.stop="uploadFile"
                :loading="fileOpLoading">
                <el-icon>
                  <Upload />
                </el-icon>
                <span>‰∏ä‰º†Êñá‰ª∂</span>
              </el-button>
              <el-button size="large" @click.stop="selectedFile = null">
                <el-icon>
                  <Close />
                </el-icon>
                <span>ÂèñÊ∂à</span>
              </el-button>
            </div>
          </div>
          <div v-else class="drop-hint">
            <el-icon class="upload-icon">
              <Upload />
            </el-icon>
            <p class="hint-title">{{ isConnected ? 'ÁÇπÂáªÈÄâÊã©Êñá‰ª∂' : 'ËØ∑ÂÖàËøûÊé•ÊúçÂä°Âô®' }}</p>
            <p class="hint-subtitle" v-if="isConnected">ÊàñÊãñÊãΩÊñá‰ª∂Âà∞Ê≠§Â§Ñ</p>
          </div>
        </div>
      </div>

      <!-- Êñá‰ª∂ÂàóË°® -->
      <div v-if="fileList.length > 0" class="file-list-section">
        <div class="section-title">
          <span>ÊúçÂä°Âô®Êñá‰ª∂</span>
          <span class="file-count">{{ fileList.length }} ‰∏™Êñá‰ª∂</span>
        </div>
        <div class="file-list">
          <div v-for="file in fileList" :key="file.name" class="file-item">
            <div class="file-item-info">
              <el-icon class="file-item-icon">
                <Document />
              </el-icon>
              <span class="file-item-name">{{ file.name }}</span>
            </div>
            <div class="file-item-actions">
              <el-button size="small" type="primary" :icon="Download" :disabled="!isConnected || fileOpLoading"
                @click="downloadFile(file.name)" circle />
              <el-button size="small" type="danger" :icon="Delete" :disabled="!isConnected || fileOpLoading"
                @click="deleteFile(file.name)" circle />
            </div>
          </div>
        </div>
      </div>
      <el-empty v-else description="ÊöÇÊó†Êñá‰ª∂" :image-size="60" />
    </el-card>

    <!-- Ê∂àÊÅØÊó•ÂøóÂç°Áâá -->
    <el-card class="message-card" shadow="never">
      <template #header>
        <div class="card-header">
          <div class="header-left">
            <el-icon class="header-icon">
              <ChatDotRound />
            </el-icon>
            <span class="card-title">Ê∂àÊÅØÊó•Âøó</span>
          </div>
          <el-button size="small" :disabled="!receivedMessages" text @click="receivedMessages = ''">
            <el-icon>
              <Delete />
            </el-icon>
            <span class="btn-text">Ê∏ÖÁ©∫</span>
          </el-button>
        </div>
      </template>
      <div class="message-container">
        <el-input type="textarea" :rows="6" v-model="receivedMessages" readonly placeholder="Á≠âÂæÖÊé•Êî∂Ê∂àÊÅØ..."
          class="message-textarea" />
      </div>
    </el-card>
  </div>
</template>

<script setup lang="ts">
import * as mqtt from "mqtt/dist/mqtt.min";
import { reactive, ref } from "vue";
import { ElNotification, ElMessageBox } from 'element-plus';
import { Download, Delete } from '@element-plus/icons-vue';

// ==================== Â∏∏ÈáèÂÆö‰πâ ====================
const CHUNK_SIZE = 3072;

// ==================== Áä∂ÊÄÅÁÆ°ÁêÜ ====================
const connection = reactive({
  protocol: "ws",
  host: "120.55.192.74",
  port: 8083,
  clientId: "emqx_vue3_" + Math.random().toString(16).substring(2, 8),
  username: "test",
  password: "123456",
  clean: true,
  connectTimeout: 30 * 1000,
  reconnectPeriod: 4000,
});

let client = ref<mqtt.MqttClient | null>(null);
const isConnected = ref(false);
const receivedMessages = ref("");
const btnLoadingType = ref("");
const configCollapsed = ref(false);

// ÁÅØÂÖâÂíåË≠¶Êä•
const lights = reactive([
  { id: 1, name: "ÂÆ¢ÂéÖ", state: false, icon: "üõãÔ∏è" },
  { id: 2, name: "È§êÂéÖ", state: false, icon: "üçΩÔ∏è" },
  { id: 3, name: "ÂçßÂÆ§", state: false, icon: "üõèÔ∏è" },
  { id: 4, name: "Ëµ∞Âªä", state: false, icon: "üö™" },
]);
const alarmControl = reactive({ state: false });

// Êñá‰ª∂ÁÆ°ÁêÜ
const fileOpLoading = ref(false);
const selectedFile = ref<File | null>(null);
const fileList = ref<{ name: string }[]>([]);
const isDragOver = ref(false);
let downloadBuffers: Record<string, Uint8Array[]> = {};

// ==================== MQTT ËøûÊé•ÁÆ°ÁêÜ ====================
const createConnection = () => {
  try {
    btnLoadingType.value = "connect";
    const { protocol, host, port, ...options } = connection;
    const connectUrl = `${protocol}://${host}:${port}/mqtt`;
    client.value = mqtt.connect(connectUrl, options);

    client.value.on("connect", () => {
      isConnected.value = true;
      btnLoadingType.value = "";
      configCollapsed.value = true;
      ElNotification({ title: 'ÊàêÂäü', message: 'MQTT ËøûÊé•ÊàêÂäü', type: 'success', duration: 2000 });

      ["smart_home/light", "smart_home/alarm", "smart_home/file"].forEach(doSubscribe);
      refreshFileList();
      queryDeviceStatus(); // ËøûÊé•ÊàêÂäüÂêéÊü•ËØ¢ËÆæÂ§áÁä∂ÊÄÅ
    });

    client.value.on("error", (error) => {
      isConnected.value = false;
      btnLoadingType.value = "";
      console.error("ËøûÊé•ÈîôËØØ:", error);
      ElNotification({ title: 'ÈîôËØØ', message: 'MQTT ËøûÊé•Â§±Ë¥•', type: 'error', duration: 3000 });
    });

    client.value.on("message", handleMessage);
  } catch (error) {
    btnLoadingType.value = "";
    console.error("ËøûÊé•ÂºÇÂ∏∏:", error);
  }
};

const destroyConnection = () => {
  if (!client.value) return;
  btnLoadingType.value = "disconnect";
  client.value.end(false, () => {
    isConnected.value = false;
    btnLoadingType.value = "";
    configCollapsed.value = false;
    ElNotification({ title: 'ÈÄöÁü•', message: 'Â∑≤Êñ≠ÂºÄËøûÊé•', type: 'info', duration: 2000 });
  });
};

const doSubscribe = (topic: string) => {
  client.value?.subscribe(topic, { qos: 1 }, (error) => {
    if (error) console.error(`ËÆ¢ÈòÖ ${topic} Â§±Ë¥•:`, error);
  });
};

const doPublish = (topic: string, payload: string) => {
  client.value?.publish(topic, payload, { qos: 1 });
};

// ==================== Ê∂àÊÅØÂ§ÑÁêÜ ====================
const handleMessage = (topic: string, message: Buffer) => {
  const msgString = message.toString();
  const timestamp = new Date().toLocaleTimeString();
  receivedMessages.value = `[${timestamp}] [${topic}] ${msgString}\n${receivedMessages.value}`;

  if (topic === "smart_home/file") {
    try {
      const msgObj = JSON.parse(msgString);
      handleFileMessage(msgObj);
    } catch (e) {
      console.error("Ëß£ÊûêÊñá‰ª∂Ê∂àÊÅØÂ§±Ë¥•:", e);
    }
  } else if (topic === "smart_home/light") {
    try {
      const msgObj = JSON.parse(msgString);
      handleLightMessage(msgObj);
    } catch (e) {
      console.error("Ëß£ÊûêÁÅØÂÖâÊ∂àÊÅØÂ§±Ë¥•:", e);
    }
  } else if (topic === "smart_home/alarm") {
    try {
      const msgObj = JSON.parse(msgString);
      handleAlarmMessage(msgObj);
    } catch (e) {
      console.error("Ëß£ÊûêÊä•Ë≠¶Ê∂àÊÅØÂ§±Ë¥•:", e);
    }
  }
};

// ==================== ÁÅØÂÖâÂíåÊä•Ë≠¶Ê∂àÊÅØÂ§ÑÁêÜ ====================
const handleLightMessage = (msgObj: any) => {
  if (msgObj.command === "list_response" && msgObj.status === "ok") {
    // Êõ¥Êñ∞ÁÅØÂÖâÁä∂ÊÄÅ
    msgObj.lights.forEach((lightData: any) => {
      const light = lights.find(l => l.id === lightData.id);
      if (light) {
        light.state = lightData.state === "ON";
        // ÂèØ‰ª•Êâ©Â±ïÊõ¥Â§öÂ±ûÊÄßÂ¶Ç‰∫ÆÂ∫¶„ÄÅËâ≤Ê∏©Á≠â
      }
    });
  }
};

const handleAlarmMessage = (msgObj: any) => {
  if (msgObj.command === "list_response" && msgObj.status === "ok") {
    // Êõ¥Êñ∞Êä•Ë≠¶Âô®Áä∂ÊÄÅ
    alarmControl.state = msgObj.state === "ON";
  }
};

// ==================== ËÆæÂ§áÁä∂ÊÄÅÊü•ËØ¢ ====================
const queryDeviceStatus = () => {
  // Êü•ËØ¢ÁÅØÂÖâÁä∂ÊÄÅ
  doPublish("smart_home/light", JSON.stringify({ command: "list" }));

  // Êü•ËØ¢Êä•Ë≠¶Âô®Áä∂ÊÄÅ
  doPublish("smart_home/alarm", JSON.stringify({ command: "list" }));
};

const queryLightStatus = () => {
  // Êü•ËØ¢ÁÅØÂÖâÁä∂ÊÄÅ
  doPublish("smart_home/light", JSON.stringify({ command: "list" }));
};

const queryAlarmStatus = () => {
  // Êü•ËØ¢Êä•Ë≠¶Âô®Áä∂ÊÄÅ
  doPublish("smart_home/alarm", JSON.stringify({ command: "list" }));
};

// ==================== ËÆæÂ§áÊéßÂà∂ ====================
const toggleLight = (light: { id: number; state: boolean }) => {
  if (!isConnected.value) return;
  light.state = !light.state;
  handleSingleLightControl(light);
};

const toggleAlarm = () => {
  if (!isConnected.value) return;
  alarmControl.state = !alarmControl.state;
  handleAlarmControl();
};

const handleSingleLightControl = (light: { id: number; state: boolean }) => {
  doPublish("smart_home/light", JSON.stringify({
    led: light.id,
    state: light.state ? "ON" : "OFF"
  }));
};

const handleAlarmControl = () => {
  doPublish("smart_home/alarm", JSON.stringify({
    state: alarmControl.state ? "ON" : "OFF"
  }));
};

const toggleAllLights = (state: boolean) => {
  lights.forEach(light => {
    if (light.state !== state) {
      light.state = state;
      handleSingleLightControl(light);
    }
  });
};

// ==================== Êñá‰ª∂Êìç‰Ωú ====================
const handleFileMessage = (msgObj: any) => {
  const handlers: Record<string, Function> = {
    list_response: handleListResponse,
    get_response: handleDownloadChunk,
    put_response: handleUploadResponse,
    delete_response: handleDeleteResponse,
  };
  handlers[msgObj.command]?.(msgObj);
};

const handleListResponse = (msgObj: any) => {
  fileOpLoading.value = false;
  if (msgObj.status === "ok") {
    fileList.value = (msgObj.files || []).map((name: string) => ({ name }));
  } else {
    ElNotification({ title: 'ÈîôËØØ', message: 'Ëé∑ÂèñÊñá‰ª∂ÂàóË°®Â§±Ë¥•', type: 'error', duration: 2000 });
  }
};

const handleUploadResponse = (msgObj: any) => {
  fileOpLoading.value = false;
  if (msgObj.status === "ok") {
    ElNotification({ title: 'ÊàêÂäü', message: 'Êñá‰ª∂‰∏ä‰º†ÊàêÂäü', type: 'success', duration: 2000 });
    selectedFile.value = null;
    refreshFileList();
  } else {
    ElNotification({ title: 'Â§±Ë¥•', message: msgObj.message || '‰∏ä‰º†Â§±Ë¥•', type: 'error', duration: 3000 });
  }
};

const handleDeleteResponse = (msgObj: any) => {
  fileOpLoading.value = false;
  if (msgObj.status === "ok") {
    ElNotification({ title: 'ÊàêÂäü', message: 'Êñá‰ª∂Â∑≤Âà†Èô§', type: 'success', duration: 2000 });
    refreshFileList();
  } else {
    ElNotification({ title: 'Â§±Ë¥•', message: 'Âà†Èô§Â§±Ë¥•', type: 'error', duration: 2000 });
  }
};

const handleDownloadChunk = (msgObj: any) => {
  if (msgObj.status !== 'ok') {
    fileOpLoading.value = false;
    ElNotification({ title: '‰∏ãËΩΩÂ§±Ë¥•', message: msgObj.message || 'Êñá‰ª∂‰∏çÂ≠òÂú®', type: 'error', duration: 3000 });
    delete downloadBuffers[msgObj.filename];
    return;
  }

  const filename = msgObj.filename;
  if (!downloadBuffers[filename]) downloadBuffers[filename] = [];

  const byteString = atob(msgObj.payload);
  const byteArray = new Uint8Array(byteString.length);
  for (let i = 0; i < byteString.length; i++) {
    byteArray[i] = byteString.charCodeAt(i);
  }
  downloadBuffers[filename].push(byteArray);

  if (msgObj.eof) {
    const parts = downloadBuffers[filename].map(u8 => u8.slice().buffer);
    const blob = new Blob(parts);
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(link.href);

    delete downloadBuffers[filename];
    fileOpLoading.value = false;
    ElNotification({ title: 'ÊàêÂäü', message: 'Êñá‰ª∂‰∏ãËΩΩÂÆåÊàê', type: 'success', duration: 2000 });
  }
};

const refreshFileList = () => {
  if (!isConnected.value) return;
  fileOpLoading.value = true;
  doPublish("smart_home/file", JSON.stringify({ command: "list" }));
};

const uploadFile = async () => {
  if (!selectedFile.value) return;

  fileOpLoading.value = true;
  const file = selectedFile.value;
  const arrayBuffer = await file.arrayBuffer();
  const totalChunks = Math.ceil(arrayBuffer.byteLength / CHUNK_SIZE);

  for (let i = 0; i < totalChunks; i++) {
    const offset = i * CHUNK_SIZE;
    const chunk = arrayBuffer.slice(offset, offset + CHUNK_SIZE);
    const base64Chunk = btoa(String.fromCharCode(...new Uint8Array(chunk)));

    doPublish("smart_home/file", JSON.stringify({
      command: "put",
      filename: file.name,
      payload: base64Chunk,
      seq: i,
      eof: i === totalChunks - 1
    }));
  }
};

const downloadFile = (fileName: string) => {
  fileOpLoading.value = true;
  doPublish("smart_home/file", JSON.stringify({ command: "get", filename: fileName }));
};

const deleteFile = (fileName: string) => {
  ElMessageBox.confirm(`Á°ÆÂÆöË¶ÅÂà†Èô§Êñá‰ª∂ "${fileName}" ÂêóÔºü`, 'Á°ÆËÆ§Âà†Èô§', {
    confirmButtonText: 'Âà†Èô§',
    cancelButtonText: 'ÂèñÊ∂à',
    type: 'warning',
  }).then(() => {
    fileOpLoading.value = true;
    doPublish("smart_home/file", JSON.stringify({ command: "delete", filename: fileName }));
  }).catch(() => { });
};

// ==================== UI ËæÖÂä©ÂáΩÊï∞ ====================
const handleFileDrop = (e: DragEvent) => {
  isDragOver.value = false;
  if (e.dataTransfer?.files?.[0]) {
    selectedFile.value = e.dataTransfer.files[0];
  }
};

const triggerFileSelect = () => {
  const input = document.createElement('input');
  input.type = 'file';
  input.onchange = (e) => {
    const target = e.target as HTMLInputElement;
    if (target.files?.[0]) selectedFile.value = target.files[0];
  };
  input.click();
};

const formatFileSize = (bytes: number): string => {
  if (bytes === 0) return '0 Bytes';
  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return `${(bytes / Math.pow(k, i)).toFixed(2)} ${sizes[i]}`;
};
</script>

<style scoped src="./MqttDemo.css"></style>