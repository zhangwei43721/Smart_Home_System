### 智能家居系统PC端开发步骤 (从0到1)

#### **项目整体架构设想**

在开始编码前，心中要有一张蓝图。我们的程序将由三个核心线程组成：
*   **UI线程：** 专门负责LVGL界面的创建、刷新和事件处理。
*   **模拟驱动线程：** 模拟硬件，负责从命令行读取指令（如 `set temp 25`）来更新设备状态，模拟真实世界的数据变化。
*   **网络线程：** 负责将设备的状态数据打包成JSON，通过网络（HTTP或MQTT）发送到您的云服务器。

这三个线程会通过一个**共享的、线程安全的数据结构**（例如一个包含所有设备状态的全局结构体和一把互斥锁）来进行交互。

---

#### **Step 1: 环境搭建与静态界面绘制**

*   **目标：** 在PC上成功运行LVGL，并显示一个静态的、没有交互功能的智能家居控制面板。
*   **任务：**
    1.  在您的开发环境（如Linux）中，配置好C语言编译器（GCC）、构建工具（Make/CMake）。
    2.  下载LVGL的PC模拟器项目，并成功编译运行，确保能看到官方的示例。
    3.  在LVGL中，创建您的主界面。至少包含：
        *   几个`lv_label`用于显示标题和数值，如“客厅温度:”、“卧室湿度:”。
        *   几个`lv_switch`或`lv_btn`用于表示设备开关，如“客厅灯”、“卧室风扇”。
*   **涉及技术点：** C语言、LVGL。
*   **产出：** 一个可以运行的程序，显示一个漂亮的但无法点击的界面。

#### **Step 2: 核心数据结构设计**

*   **目标：** 将系统的“状态”与“表现（UI）”分离。这是软件工程中最重要的思想之一。
*   **任务：**
    1.  设计一个`struct`来表示一个智能设备，例如：
        ```c
        typedef struct {
            char name[32]; // 设备名称 e.g., "客厅灯"
            int type;      // 设备类型 0-开关, 1-传感器
            float value;   // 传感器的值
            int status;    // 开关的状态 0-关, 1-开
        } Device;
        ```
    2.  创建一个全局的设备数组或链表来管理家中所有的设备。
        ```c
        #define MAX_DEVICES 10
        Device g_devices[MAX_DEVICES];
        ```
*   **涉及技术点：** C语言、数据结构。
*   **产出：** 定义了`device.h`和`device.c`文件，用于管理所有设备的数据。

#### **Step 3: UI与数据双向绑定**

*   **目标：** 让UI能够**反映**数据结构中的状态，并且UI上的操作能够**修改**数据结构。
*   **任务：**
    1.  编写一个 `update_ui_from_data()` 函数。该函数遍历`g_devices`数组，并将设备的状态更新到对应的LVGL组件上（例如，将温度值设置给label，将开关状态设置给switch）。
    2.  为主循环添加定时器，定期调用`update_ui_from_data()`，实现UI的自动刷新。
    3.  为开关（switch）等组件注册事件回调函数。**在回调函数里，只修改`g_devices`数组中对应设备的状态，而不是直接控制UI**。
        ```c
        // 伪代码
        void light_switch_callback(lv_event_t * e) {
            // 找到对应的设备
            int device_index = find_device_by_name("客厅灯");
            // 修改数据结构中的状态
            g_devices[device_index].status = lv_obj_has_state(get_target_switch(), LV_STATE_CHECKED);
        }
        ```
*   **涉及技术点：** C语言、数据结构、LVGL。
*   **产出：** 一个可以交互的UI。点击开关，对应的设备状态（在内存中）会改变。由于UI会自动刷新，你看上去就像是直接操作了UI。

#### **Step 4: 引入多线程分离任务**

*   **目标：** 搭建起项目的多任务并发架构，为后续的模拟输入和网络通信做准备。
*   **任务：**
    1.  学习并使用 `pthreads` 库。
    2.  创建**UI线程**：将所有LVGL相关的代码（初始化、事件处理循环`lv_timer_handler`）都放进这个线程的执行函数中。
    3.  创建**后台逻辑线程（暂时可以叫模拟驱动线程）**：创建一个空的循环，后续将在这里添加模拟输入和网络功能。
    4.  引入互斥锁（`pthread_mutex_t`）。当任何线程需要读写全局的`g_devices`数组时，都必须先加锁，操作完后解锁，以保证数据安全。
*   **涉及技术点：** C语言、多线程。
*   **产出：** 一个多线程程序。UI界面依然可以流畅操作，同时后台有一个独立的线程在运行。

#### **Step 5: 命令行模拟硬件输入**

*   **目标：** 实现从外部控制系统状态，模拟真实的传感器数据上报。
*   **任务：**
    1.  在**后台逻辑线程**中，添加代码来读取标准输入（`stdin`），即你的命令行。
    2.  设计简单的命令格式，例如 `set temp 26.5` 或 `toggle light`。
    3.  循环读取命令行输入，解析命令。当收到一个有效的命令后：
        *   **加锁**。
        *   修改`g_devices`数组中对应设备的状态。
        *   **解锁**。
*   **涉及技术点：** IO编程、多线程。
*   **产出：** 你的程序运行时，你可以在命令行输入指令来改变设备状态，并且UI界面会**自动刷新**显示最新的状态。例如，你输入`set temp 26.5`，界面上的温度值就会 magically 变成26.5。

#### **Step 6: 网络通信与数据上云**

*   **目标：** 将设备的状态数据周期性地发送到你的云服务器。
*   **任务：**
    1.  **选择协议：** MQTT是物联网首选，但HTTP也可以。我们先用更简单的HTTP POST。
    2.  **JSON封装：** 引入一个轻量级的C语言JSON库（如 `cJSON`）。编写一个函数，该函数可以遍历`g_devices`数组，并将其状态打包成一个JSON字符串。
        ```json
        {
          "home_id": "my_home_01",
          "devices": [
            {"name": "客厅灯", "status": 1},
            {"name": "客厅温度", "value": 26.5}
          ]
        }
        ```
    3.  **网络发送：** 在**后台逻辑线程**中（或者可以再创建一个独立的网络线程），添加一个定时逻辑（例如每5秒一次）：
        *   **加锁**。
        *   调用函数生成JSON字符串。
        *   **解锁**。
        *   使用Socket编程，建立一个HTTP连接到你的服务器，发送一个POST请求，请求体就是这个JSON字符串。
    4.  **云服务器端：** 在你的云服务器上，用一个极其简单的脚本（Python Flask或Node.js Express）搭建一个Web服务，它只需要一个API接口，接收POST请求，然后把收到的JSON数据打印在服务器的控制台上即可。
*   **涉及技术点：** 多线程、网络编程（HTTP、JSON）。
*   **产出：** 你的智能家居程序在运行时，你的云服务器后台会源源不断地收到并打印出你家里的设备状态数据。

```
